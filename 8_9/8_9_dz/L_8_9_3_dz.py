"""
Создайте базовый абстрактный класс “Элемент” с методами вычисления нормы и модуля.

Реализуйте производные классы “Комплексное число” и “Вектор3D”
с собственными методами вычисления нормы и модуля.
"""

from math import sqrt

# Импорт абстрактного базового класса и декоратора
from abc import ABC, abstractmethod

# Определение абстрактного базового класса Element
class Element (ABC):

    @abstractmethod
    def norma(self):
        """
        Абстрактный метод вычисления нормы элемента
        :return: Норма элемента
        """
        pass

    @abstractmethod
    def module(self):
        """
        Абстрактный метод вычисления модуля элемента
        :return: Модуль элемента
        """
        pass


class Complex_digit(Element):
    def __init__(self, a, b):
        """
        Иницализатор класса Complex_digit
        :param a: действительная часть комплексного числа
        :param b: мнимая часть комплексного числа
        :param digit: комплексное число
        """
        self.a = a
        self.b = b
        self.digit = complex(self.a, self.b)
        print(f"Объект комплексное число {self.digit} был создан!")

    # Реализация абстрактного метода module
    def module(self):
        """
        Вычисление модуля комплексного числа
        {Для комплексного числа модуль - это корень из суммы квадратов
        его действительной и мнимой частей}
        :return: Модуль комплексного числа
        """
        return round(sqrt(self.a ** 2 + self.b ** 2), 2)

    # Реализация абстрактного метода norma
    def norma(self):
        """
        Вычисление нормы комплексного числа
        {Для комплексного числа норма - это сумма квадратов
        его действительной и мнимой частей или его модуль в квадрате}
        :return: Норма комплексного числа
        """
        # первый способ вычисления нормы: return self.a ** 2 + self.b ** 2
        return round(self.module() ** 2, 2)


class Vector_3D(Element):
    def __init__(self, x, y, z):
        """
        Иницализатор класса Vector_3D
        По умолчанию считается, что точка, из которой исходит 3D вектор,
        имеет координаты (0, 0, 0)
        :param x: координата конечной точки 3D вектора по оси X
        :param y: координата конечной точки 3D вектора по оси Y
        :param z: координата конечной точки 3D вектора по оси Z
        :param vector: 3D вектор
        """
        self.x = x
        self.y = y
        self.z = z
        self.vector = (self.x, self.y, self.z)
        print(f"Объект 3D вектор {self.vector} был создан!")

    # Реализация абстрактного метода module
    def module(self):
        """
        Вычисление модуля 3D вектора
        {Для 3D вектора модуль - это квадратный корень из суммы
        квадратов его координат}
        :return: Модуль 3D вектора
        """
        return round(sqrt(self.x ** 2 + self.y ** 2 + self.z ** 2), 2)

    # Реализация абстрактного метода norma
    def norma(self):
        """
        Вычисление нормы 3D вектора
        {Норма 3D вектора - это максимальное из абсолютных значений координат}
        :return: Норма 3D вектора
        """
        return max(map(abs, self.vector))


# Создание объектов классов-потомков,
# вызов на этих объектах, реализованных абстрактных методов

c1 = Complex_digit(4, -7)
print(f"Модуль комплексного числа {c1.digit} равен {c1.module()}")
print(f"Норма комплексного числа {c1.digit} равна {c1.norma()}")

print('*'*50)

v1 = Vector_3D(7, 4, -10)
print(f"Модуль 3D вектора {v1.vector} равен {v1.module()}")
print(f"Норма 3D вектора {v1.vector} равна {v1.norma()}")

